#!/usr/bin/env ruby
AppVersion = "v0.2011.03.13"
AppName = File.basename( $0 )
#
# Wolfgang Woehl v0.2011
#
# Ruby geeks: If you value your sanity don't read beyond this line. I'm working on it ...

require 'fileutils'
if RUBY_VERSION <= '1.9'
  require 'ftools' # File.copy
  begin
    require 'rubygems'
  rescue LoadError
  end
end
require 'optparse'
require 'ostruct'
require 'openssl'
require 'digest'
require 'base64'
require 'pp'
require 'tempfile'
require 'nokogiri'
require 'highline/import'
require 'pathname'

$LOAD_PATH << './lib'
require 'Reel'
require 'CPL_SMPTE_429_7_2006'
require 'KDM_SMPTE_430_1_2006'
require 'Options'

require 'DC_Signature'
require 'DC_Signature_KDM'
require 'PKL_SMPTE_429_8_2007'
require 'AM_SMPTE_429_9_2007'
require 'MXF_Metadata'
require 'DC_Tools'
require 'Tools'
require 'X509_Certificate_Chain'
require 'Logger'

commandline = reconstruct_commandline( ARGV )
# destructive parse
@options = Options.parse( ARGV )
@logger = Logger.new( prefix = '*', @options.verbosity )


def reel_list( files )
  reels = Array.new
  files.each do |file|
    meta = MXF_Metadata.new( image_mxf ).hash
  end
  #
end

def make_cpl( reels )
    
end

def write_cpl
  # Write CompositionPlaylist
  @logger.info( 'Write CPL' )
  cpl_uuid = `kmuuidgen -n` # FIXME
  @logger.debug( "CPL UUID:       #{ cpl_uuid }" )
  cpl_file = File.join( @dcpdir, 'cpl_' + cpl_uuid + '_.xml' )
  cpl = CPL_SMPTE_429_7_2006.new( 
    cpl_uuid,
    @options.dcp_encrypt,
    image_mxf.to_a, # reels
    @source_audio.empty? ? nil : audio_mxf.to_a, # reels
    annotation = @options.annotation,
    issue_date = DateTime.now.to_s,
    issuer = @options.issuer,
    creator = "#{ AppName } #{ AppVersion } smpte cpl",
    content_title = @options.dcp_title,
    content_kind = @options.dcp_kind,
    content_version_id = cpl_uuid + '_' + issue_date,
    content_version_label = content_version_id,
    rating_list = nil
  )
  if @options.sign == TRUE
    cpl_xml = DCSignature.new( cpl.xml, signer_key_file, ca_cert_file, intermediate_cert_file, certchain_objs ).xml
  else
    cpl_xml = cpl.xml
  end
  File.open( cpl_file, 'w' ) { |f| f.write( cpl_xml ) }
end


def make_pkl
  # Write PackingList
  @logger.info( 'Write PKL ...' )
  # might be cumulative DCP, end up with 1 pkl to cover all
  obsolete_pkls = Dir.glob( File.join( @dcpdir, 'pkl_*_.xml' ) ) # FIXME check xml for packing list
  obsolete_pkls.each do |obsolete_pkl|
    @logger.debug( "Obsolete:   #{ File.basename( obsolete_pkl ) }" )
    File.delete( obsolete_pkl )
  end
  pkl_assets = Array.new
  pkl_assets << Dir.glob( File.join( @dcpdir, 'cpl_*_.xml' ) )
  pkl_assets << Dir.glob( File.join( @dcpdir, '*_.mxf' ) )
  pkl_uuid = `kmuuidgen -n`
  @logger.debug( "PKL UUID:       #{ pkl_uuid }" )
  pkl_file = File.join( @dcpdir, 'pkl_' + pkl_uuid + '_.xml' )
  pkl = PKL_SMPTE_429_8_2007.new(
    pkl_uuid,
    @options.annotation, # FIXME
    issue_date = DateTime.now.to_s,
    @options.issuer,
    creator = "#{ AppName } #{ AppVersion } smpte pkl",
    pkl_assets.flatten
  )
  if @options.sign == TRUE
    pkl_xml = DCSignature.new( pkl.xml, signer_key_file, ca_cert_file, intermediate_cert_file, certchain_objs ).xml
  else
    pkl_xml = pkl.xml
  end
  File.open( pkl_file, 'w' ) { |f| f.write( pkl_xml ) }
  return pkl_assets.flatten
end
  
  
def make_map( pkl_assets )
  # Write Assetmap
  @logger.info( 'Write ASSETMAP' )
  am_assets = Array.new
  am_assets << pkl_assets
  am_assets << pkl_file
  am_uuid = `kmuuidgen -n`
  @logger.debug( "AM UUID:        #{ am_uuid }" )
  am_file = File.join( @dcpdir, 'ASSETMAP.xml' )
  am = AM_SMPTE_429_9_2007.new(
    am_uuid,
    issue_date = DateTime.now.to_s,
    @options.issuer,
    creator = "#{ AppName } #{ AppVersion } smpte am",
    am_assets.flatten
  )
  File.open( am_file, 'w' ) { |f| f.write( am.xml ) }

  # readme and report
  readme_file_name = @options.annotation.gsub( /[\\\/\&: ]/, '_' ) + '.readme'
  readme_file_path = File.join( @dcpdir, readme_file_name )
  File.open( readme_file_path, 'w' ) { |f| f.write( commandline + "\n" ) }
  final_report( sequence_frames, fps, @options.transition_and_timing, @options.keep )
  cleanup_workdir( @options.keep )
  @logger.info( "DCP done" )
end


### KDM mode
def make_kdm
  @logger = Logger.new( prefix = 'kdm *', @options.verbosity )
  
  mandatory = [ 'xmlsec1', 'openssl', 'kmuuidgen' ]
  available_mandatory, missing_mandatory = check_external( mandatory )
  if ! missing_mandatory.empty?
    @logger.info( "Required tools: #{ mandatory.join( ', ' ) }" )
    @logger.info( "Missing tool#{ missing_mandatory.size != 1 ? 's' : '' }: #{ missing_mandatory.join( ', ' ) }" )
    @logger.info( "Check your installation" )
    exit
  else
    @logger.info( "All necessary tools available" )
  end

  # failure of any of the following checks is reason to exit
  kdm_no_go = Array.new
  kdm_issue_date = DateTime.now
  
  # set up signature context
  # FIXME check availability and validity of certificates/keys
  # FIXME include verification of certchain and matrjoschka-contained validity periods
  if ENV[ 'CINEMACERTSTORE' ].nil?
    @logger.info( "Expecting certificates at $CINEMACERTSTORE. Set this environment variable with 'export CINEMACERTSTORE=<path>'" )
    @logger.info( "Run make-dc-certificate-chain.rb in that directory to create the required certificates." )
    @logger.info( "Sorry for the inconvenience. Work in progress" )
    kdm_no_go << 'CINEMACERTSTORE not set'
  else
    cinemacertstore = ENV[ 'CINEMACERTSTORE' ]
    @logger.debug( "CINEMACERTSTORE is set to #{ cinemacertstore }" )
    if File.exists?( cinemacertstore ) and File.ftype( cinemacertstore ) == 'directory'
      signer_key_file, signer_cert_file, signer_cert_obj, ca_cert_file, intermediate_cert_file, certchain_text, certchain_objs = signature_context
      signer_cert_thumbprint = dc_thumbprint( signer_cert_file )
      @logger.info( "KDM signer: #{ signer_cert_obj.subject.to_s }" )
    else
      @logger.info( "CINEMACERTSTORE should point at a directory holding your private signer key and associated certificates" )
      kdm_no_go << 'CINEMACERTSTORE not a directory'
    end
  end
  
  # check for key directory
  @keysdir = File.join( @dietrichdir, 'keys' )
  if ( File.exists?( @keysdir ) and File.ftype( @keysdir ) == 'directory' )
    @logger.debug( "Content keystore at: #{ @keysdir }" )
  else
    @logger.info( "No content keystore found (Looking for #{ @keysdir })" )
    @logger.info( "#{ $0 } will set it up once it builds an encrypted DCP" )
    kdm_no_go << 'No content keystore'
  end
  
  # check presence and validity of cpl and referenced content keys
  if @options.kdm_cpl == NIL
    @logger.info( "No CPL specified. Use --cpl <CPL>" )
    kdm_no_go << 'No CPL'
  else
    # Get CPL info
    if File.exists?( @options.kdm_cpl ) and File.ftype( @options.kdm_cpl ) == 'file'
      xml_obj = Nokogiri::XML( File.read( @options.kdm_cpl ) )
      if xml_obj.root == NIL
        @logger.info( "#{ @options.kdm_cpl } is not XML" )
        kdm_no_go << 'No CPL'
      else
        if xml_obj.root.node_name == 'CompositionPlaylist' # FIXME validation
          @logger.info( "CPL: #{ @options.kdm_cpl }" )
          cpl_uuid, cpl_content_title_text, cpl_key_ids_types = kdm_cpl_info( xml_obj )
          cpl_content_authenticator = signer_cert_thumbprint( xml_obj )
          if cpl_key_ids_types.size == 0
            @logger.info( "KDM not applicable: #{ @options.kdm_cpl } doesn't reference content keys" )
            kdm_no_go << 'No content keys referenced in CPL'
          else
            @logger.info( "CPL references #{ cpl_key_ids_types.size } content key#{ ( cpl_key_ids_types.size != 1 ) ? 's' : '' }" )
            # check presence and local specs compliance of content keys
            @logger.info( "Checking content keys ..." )
            keys = Array.new
            keys_missing = 0
            keys_invalid = 0
            cpl_key_ids_types.each do |kit|
              if File.exists?( File.join( @keysdir, kit.keys.first ) )
                candidate_key = File.read( File.join( @keysdir, kit.keys.first ) )
                if key_spec_valid?( candidate_key )
                  @logger.debug( "   Found: #{ kit.keys.first }" )
                  keys << candidate_key
                else
                  @logger.info( "Key file #{ kit.keys.first } doesn't fit specs: <UUID>:<Key type>:<Key>" )
                  keys_invalid += 1
                end
              else
                @logger.info( "   Not found: #{ kit.keys.first }" )
                keys_missing += 1
              end
            end
            if keys_missing > 0
              @logger.info( "Keys not found: #{ keys_missing }/#{ cpl_key_ids_types.size }" )
              kdm_no_go << 'Content key(s) missing'
            end
            if keys_invalid > 0
              @logger.info( "Key specs invalid: #{ keys_invalid }/#{ cpl_key_ids_types.size }" )
              kdm_no_go << 'Content key(s) not valid'
            end
            if keys_missing + keys_invalid == 0
              @logger.info( "All content keys present" )
            end
          end
        else
          @logger.info( "#{ @options.kdm_cpl } is not a composition playlist" )
          kdm_no_go << 'No CPL'
        end
      end
    else
      @logger.info( 'Specify a valid XML file' )
      kdm_no_go << 'No CPL'
    end
  end
  
  # check KDM time window
  kdm_not_valid_before = ( DateTime.now + @options.kdm_start ) # check for valid window
  kdm_not_valid_after = ( DateTime.now + @options.kdm_end )
  if kdm_not_valid_before > kdm_not_valid_after
    @logger.info( "KDM time window out of order" )
    kdm_no_go << 'KDM time window out of order'
  else
    # defer logger.info to after we have a valid target certificate in order to check containment of time window in the target device's validity period
  end
  
  # check presence and validity of target certificate
  if @options.kdm_target == NIL
    @logger.info( "No target certificate specified. Use --target <certificate>" )
    kdm_no_go << 'No target'
  else
    if File.exists?( @options.kdm_target ) and File.ftype( @options.kdm_target ) != 'directory'
      begin
        recipient_cert_obj = OpenSSL::X509::Certificate.new( File.read( @options.kdm_target ) )
        recipient_cert_thumbprint = dc_thumbprint( @options.kdm_target )
        recipient_cn_name = 'TEST'
        # make target name for kdm filename and print RDN info
        @logger.debug( "Target:" )
        recipient_cert_obj.subject.to_a.each do |rdn|
          @logger.debug( "   #{ [ rdn[ 0 ], rdn[ 1 ] ].join( '=' ) }" )
          if rdn[ 0 ] == 'CN'
            recipient_cn_name = rdn[ 1 ].split( /^([^.]+.)/ ).last # Not sure. This is supposed to pick up everything after the first dot
            @logger.debug( "Target device name: #{ recipient_cn_name }" )
          end
        end
        recipient_description = recipient_cn_name
        
        # signer cert valid during requested time window?
        if time_to_datetime( signer_cert_obj.not_before ) < kdm_not_valid_before and time_to_datetime( signer_cert_obj.not_after ) > kdm_not_valid_after
          @logger.info( "Signer certificate is valid during requested KDM time window" )
        else
          @logger.info( "Signer certificate's validity period does not contain requested KDM time window" )
          @logger.info( "   valid from  #{ time_to_datetime( signer_cert_obj.not_before ).to_s }" )
          @logger.info( "   valid until #{ time_to_datetime( signer_cert_obj.not_after ).to_s }" )
          kdm_no_go << 'Signer certificate validity'
        end
        # target cert valid during requested time window?
        if time_to_datetime( recipient_cert_obj.not_before ) < kdm_not_valid_before and time_to_datetime( recipient_cert_obj.not_after ) > kdm_not_valid_after
          @logger.info( "Target certificate is valid during requested KDM time window" )
        else
          @logger.info( "Target certificate's validity period does not contain requested KDM time window" )
          @logger.info( "   valid from  #{ time_to_datetime( recipient_cert_obj.not_before ).to_s }" )
          @logger.info( "   valid until #{ time_to_datetime( recipient_cert_obj.not_after ).to_s }" )
          kdm_no_go << 'Target certificate validity'
        end
        # deferred from KDM time window check
        @logger.info( "KDM requested valid from  #{ datetime_friendly( kdm_not_valid_before ) }" )
        @logger.info( "KDM requested valid until #{ datetime_friendly( kdm_not_valid_after ) }" )

      rescue OpenSSL::X509::CertificateError => e # recipient_cert_obj.class == NilClass
        @logger.info( "#{ @options.kdm_target }: #{ e.message }" )
        kdm_no_go << 'Target OpenSSL::X509::CertificateError'
      end
    else
      @logger.info( 'Specify a valid target certificate in PEM format' )
      kdm_no_go << 'No target'
    end
  end
  
  ### exit now if any of the requirements for KDM generation are not met
  if kdm_no_go.size > 0
    kdm_no_go.each do |error|
      @logger.info( "Error: #{ error }" )
    end
    @logger.info( "KDM generation skipped. See above" )
    exit
  else
    @logger.info( "KDM requirements all met" )
  end
  
  kdm_message_uuid = `kmuuidgen -n`
  kdm_message_annotation = @options.annotation
  device_list_identifier = `kmuuidgen -n` # FIXME

  #
  cipher_data_payloads = Array.new
  cpl_key_ids_types.each do |kit|
    # FIXME
    key = File.read( File.join( @keysdir, kit.keys.first ) ).split( ':' ).last
    key_id = kit.keys.first
    cipher_data_payload = cipher_data_payload_binary_package( 
      signer_cert_thumbprint,
      cpl_uuid,
      kit.values.first, # key_type (plus yeah, i know, idiotic data type chosen for key_ids_types. i'll make up my mind wrt how and where to get key type from)
      key_id,
      kdm_not_valid_before.to_s,
      kdm_not_valid_after.to_s,
      key
    )
    tmp = Tempfile.new( 'cinemaslides-' )
    tmpfile = File.open( tmp.path, 'w' ) { |f| f.write cipher_data_payload ; f.close }
    @logger.debug( "Encrypt payload for content key ID #{ key_id }" )
    # targeting ...
    cipher_data_payload_encrypted_b64 = `openssl rsautl -encrypt -oaep -certin -inkey #{ @options.kdm_target } -in #{ tmp.path } | openssl base64`.chomp
    cipher_data_payloads << cipher_data_payload_encrypted_b64
  end
    
  # KDM data and template for signature
  @logger.debug( 'Prepare KDM XML for signature' )
  kdm_xml = KDM_SMPTE_430_1_2006.new(
    kdm_message_uuid,
    kdm_message_annotation,
    kdm_issue_date.to_s,
    signer_cert_obj,
    recipient_cert_obj,
    cpl_uuid,
    cpl_content_title_text,
    cpl_content_authenticator,
    kdm_not_valid_before,
    kdm_not_valid_after,
    device_list_identifier,
    recipient_description,
    recipient_cert_thumbprint,
    keys,
    cipher_data_payloads
  ).xml
  
  # Sign and write kdm to disk
  @logger.debug( 'Sign and write KDM to disk' )

  kdm_signed_xml = DC_Signature_KDM.new( 
    kdm_xml,
    signer_key_file,
    ca_cert_file,
    intermediate_cert_file,
    certchain_objs
  ).xml
  
  kdm_cpl_content_title = cpl_content_title_text.upcase.gsub( ' ', '-' )[0..19]
  kdm_creation_facility_code = @options.issuer.upcase.gsub( ' ', '' )[0..2]
  kdm_file = "k_#{ kdm_cpl_content_title }_#{ recipient_cn_name }_#{ yyyymmdd( kdm_not_valid_before ) }_#{ yyyymmdd( kdm_not_valid_after ) }_#{ kdm_creation_facility_code }_OV_#{ kdm_message_uuid[0..7] }.xml"
  if File.exists?( kdm_file )
    @logger.info( "KDM exists: #{ kdm_file }" )
    @logger.info( "4 bytes UUID collision: #{ kdm_message_uuid }. Not overwriting" )
    exit
  else
    File.open( kdm_file, 'w' ) { |f| f.write( kdm_signed_xml ) }
    @logger.info( "Pick up KDM at #{ kdm_file }" )
    @logger.info( 'KDM done' )
  end
  

end ### KDM mode


@logger.info( "#{ AppName } #{ AppVersion }" )
# cinemaslides requires ruby 1.8.7 and will not work with > 1.9, yet.
# the changes required for 1.9 are subtle. just haven't gotten around to it, yet. coming up
if RUBY_VERSION < '1.8.7' or RUBY_VERSION >= '1.9'
  @logger.info( "#{ AppName } requires ruby >= 1.8.7 and < 1.9. Your ruby version: #{ RUBY_VERSION }" )
  exit
end
@logger.debug( commandline )


#
if ENV[ 'DIETRICHDIR' ].nil?
  @dietrichdir = File.join( ENV[ 'HOME' ], "dietrichdir" )
  @logger.debug( "DIETRICHDIR not set. Will use #{ @dietrichdir }" )
else
  DIETRICHDIR = File.expand_path( ENV[ 'DIETRICHDIR' ] )
  @logger.debug( "DIETRICHDIR is set to #{ DIETRICHDIR }" )
  @dietrichdir = DIETRICHDIR
end


################################# modes switch
case @options.mode
when 'cpl'
  reels = reel_list( ARGV )
  make_cpl( reels )
  exit
when 'pkl'
  pkl_assets = make_pkl # ?
  make_map( pkl_assets )
  exit
when 'kdm'
  make_kdm
  exit
when 'signature-context'
  require 'DC_Signature_Context'
  files = get_argv_files
  context = DC_Signature_Context.new( files )
  if context.valid?
    puts context.messages
    puts "OK"
  else
    if ! context.errors[ :pre_context ].empty?
      puts context.errors[ :pre_context ]
      puts "No valid signature context found"
      exit
    else
      puts context.messages
      puts "No valid signature context found"
      exit
    end
  end

end
################################# end modes switch


  
  

# check required tools -- well, it's still messy
def missing_exit( tool )
  @logger.info( "#{ tool } not available. Check your installation" )
  exit
end

mandatory = [ 'convert', 'identify', 'sox', 'soxi', 'asdcp-test', 'kmuuidgen' ]
if @options.sign == TRUE
  mandatory << 'xmlsec1'
end
if @options.dcp_encrypt == TRUE
  mandatory << 'kmrandgen'
  mandatory << 'xmlsec1'
end
available_mandatory, missing_mandatory = check_external( mandatory )

@logger.debug( "Available tools: #{ available_mandatory.sort.join(', ') }" ) unless available_mandatory.empty?
@logger.debug( "Missing tools: #{ missing_mandatory.join(', ') }" ) unless missing_mandatory.empty?
@logger.debug( "All necessary tools available" ) if missing_mandatory.empty?

if missing_mandatory.size > 0
  @logger.info( "Check your installation" )
  exit
end


### Get options and initialize
# check dcp related options 
  if @options.dcp_encrypt == TRUE
    @options.sign = TRUE
  end
  if @options.sign == TRUE
    if ENV[ 'CINEMACERTSTORE' ].nil?
      @logger.critical( "CINEMACERTSTORE not set. Cannot locate signer's private key, issuing certificates and certificate chain" )
      exit
    else
      CINEMACERTSTORE = ENV[ 'CINEMACERTSTORE' ]
      signer_key_file, signer_cert_file, signer_cert_obj, ca_cert_file, intermediate_cert_file, certchain_text, certchain_objs = signature_context
    end
  end
  # mark assets with encoder ids
  @logger.debug( "DCP related options ok" )


# check provided files for readability, type and validity
###


# set up directories to write output to. These locations are created upon demand only, hence the clustered mkdir's. FIXME
@workdir = File.join( @dietrichdir, "#{ File.basename( $0 ) }_#{ timestamp }_#{ @output_type }" )
@assetsdir = File.join( @dietrichdir, "assets" )
@keysdir = File.join( @dietrichdir, 'keys' )
if confirm_or_create( @dietrichdir ) == TRUE
  @logger.debug( "#{ @dietrichdir } is writeable" )
else
  @logger.critical( "#{ @dietrichdir } is not writeable. Check your mounts or export DIETRICHDIR to point to a writeable location." )
  exit
end
if @options.dcp_user_output_path == nil
  @dcpdir = File.join( @workdir, "dcp" )
else
  @dcpdir = @options.dcp_user_output_path
end
# silently ignore option.dcp_user_output_path when previewing
  # ask for confirmation to add files if -o | --dcp_out is set and the location already exists and is not empty
  if @options.dcp_user_output_path != nil and File.exists?( @dcpdir ) and Dir.entries( @dcpdir ).size > 2 # platform-agnostic Dir.empty? anyone?
    if File.writable?( @dcpdir )
      if ENV[ 'HOME' ] == File.join( File.dirname( @dcpdir ), File.basename( @dcpdir ) ) # confirm direct write into HOME
        @logger.critical( "Cluttering HOME" )
        exit if agree( "Are you sure you want to write DCP files directly into #{ ENV[ 'HOME' ] }? " ) == FALSE
      else
        exit if agree( "#{ @dcpdir } already exists. Add current DCP files to it? " ) == FALSE
      end
    end
  end
  if confirm_or_create( @dcpdir ) == TRUE
    @logger.debug( "#{ @dcpdir } is writeable" )
  else
    @logger.critical( "#{ @dcpdir } is not writeable. Check your mounts and permissions." )
    exit
  end


